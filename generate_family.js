// Generated by CoffeeScript 1.3.3
(function() {
  var TwoDimStruc, analyse, analyseAPath, analyseFile, argparse, args, attrSchema, autonumRules, canBeParsed, computeOrder, cson, defaultValuesRules, dir, exec, famSchema, firstAttributesLine, firstLineSchema, fs, generateAttributes, generateFirstPart, getCSVFileName, initFirstLine, notAttrSchema, onChange, parse, parser, pathUtil, populateDefaultValues, usableFormat, xml2js, yaml,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  pathUtil = require('path');

  fs = require('fs');

  argparse = require('argparse');

  cson = require('cson');

  xml2js = require('xml2js');

  yaml = require('js-yaml');

  exec = require('child_process').exec;

  TwoDimStruc = (function() {

    function TwoDimStruc() {
      this.convertToCSV = __bind(this.convertToCSV, this);

      this.getColumns = __bind(this.getColumns, this);

      this.getRows = __bind(this.getRows, this);

      this.getColumn = __bind(this.getColumn, this);

      this.getRow = __bind(this.getRow, this);

      this.getElement = __bind(this.getElement, this);

      this.addElement = __bind(this.addElement, this);
      this.values = {};
      this.x = {};
      this.y = {};
      this.maxX = 0;
      this.maxY = 0;
    }

    TwoDimStruc.prototype.addElement = function(value, x, y) {
      var id;
      id = x + ":" + y;
      this.values[id] = value;
      this.x[id] = x;
      this.y[id] = y;
      if (this.maxX < x) {
        this.maxX = x;
      }
      if (this.maxY < y) {
        return this.maxY = y;
      }
    };

    TwoDimStruc.prototype.getElement = function(x, y) {
      if (this.values[x + ":" + y] != null) {
        return this.values[x + ":" + y];
      } else {
        return void 0;
      }
    };

    TwoDimStruc.prototype.getRow = function(x) {
      var id, ids, indice, max, result, value, _i, _len;
      result = {};
      max = 0;
      ids = (function() {
        var _ref, _results;
        _ref = this.x;
        _results = [];
        for (id in _ref) {
          value = _ref[id];
          if (value === x) {
            _results.push(id);
          }
        }
        return _results;
      }).call(this);
      for (_i = 0, _len = ids.length; _i < _len; _i++) {
        id = ids[_i];
        indice = parseInt(id.split(":")[1], 10);
        result[indice] = this.values[id];
        if (max < indice) {
          max = indice;
        }
      }
      return {
        content: result,
        max: max
      };
    };

    TwoDimStruc.prototype.getColumn = function(y) {
      var id, ids, indice, max, result, value, _i, _len;
      result = {};
      max = 0;
      ids = (function() {
        var _ref, _results;
        _ref = this.y;
        _results = [];
        for (id in _ref) {
          value = _ref[id];
          if (value === y) {
            _results.push(id);
          }
        }
        return _results;
      }).call(this);
      for (_i = 0, _len = ids.length; _i < _len; _i++) {
        id = ids[_i];
        indice = parseInt(id.split(":")[0], 10);
        result[indice] = this.values[id];
        if (max < indice) {
          max = indice;
        }
      }
      return {
        content: result,
        max: max
      };
    };

    TwoDimStruc.prototype.getRows = function() {
      var num, result;
      result = {};
      num = 0;
      while (num <= this.maxX) {
        result[num] = this.getRow(num);
        num += 1;
      }
      return result;
    };

    TwoDimStruc.prototype.getColumns = function() {
      var num, result;
      result = {};
      num = 0;
      while (num <= this.maxY) {
        result[num] = this.getRow(num);
        num += 1;
      }
      return result;
    };

    TwoDimStruc.prototype.convertToCSV = function(separator, escape) {
      var csv, currentRow, currentValue, i, j, _ref;
      if (separator == null) {
        separator = ";";
      }
      if (escape == null) {
        escape = "";
      }
      csv = "";
      i = 0;
      while (i <= this.maxX) {
        currentRow = this.getRow(i);
        j = 0;
        while (j <= this.maxY) {
          currentValue = (_ref = currentRow.content[j]) != null ? _ref : "";
          if (j === 0) {
            csv += "" + currentValue;
          } else {
            csv += "" + separator + currentValue;
          }
          j += 1;
        }
        csv += "\n";
        i += 1;
      }
      return csv;
    };

    return TwoDimStruc;

  })();

  usableFormat = {
    json: JSON.parse,
    yaml: yaml.load,
    cson: cson.parseSync
  };

  attrSchema = {
    id: 1,
    parent: 2,
    label: 3,
    intitle: 4,
    inabstract: 5,
    type: 6,
    order: 7,
    visibility: 8,
    need: 9,
    link: 10,
    phpfile: 11,
    phpfunc: 12,
    elink: 13,
    constraint: 14,
    options: 15,
    commentaires: 16
  };

  notAttrSchema = ["modattr", "children", "attr", "default"];

  famSchema = {
    father: {
      column: 1,
      row: 1
    },
    title: {
      column: 2,
      row: 1
    },
    id: {
      column: 3,
      row: 1
    },
    classname: {
      column: 4,
      row: 1
    },
    logicalname: {
      column: 5,
      row: 1
    }
  };

  firstLineSchema = {
    "//": 0,
    Father: 1,
    Title: 2,
    Id: 3,
    Classe: 4,
    "Logical Name": 5
  };

  autonumRules = {
    'tab': 1000,
    'frame': 100
  };

  defaultValuesRules = {
    'global': {
      visibility: "W",
      intitle: "N",
      inabstract: "N"
    },
    'htmltext': {
      options: 'toolbar=Basic|toolbarexpand=n'
    },
    'enum': {
      options: 'bmenu=no|eunset=yes|system=yes'
    },
    'array': {
      options: 'vlabel=up'
    },
    'longtext': {
      options: 'editheight=4em'
    }
  };

  populateDefaultValues = function(attr) {
    var defaultValues, key, type, value, _ref;
    if (attr.type != null) {
      for (type in defaultValuesRules) {
        defaultValues = defaultValuesRules[type];
        if (attr.type === type || type === "global") {
          for (key in defaultValues) {
            value = defaultValues[key];
            if ((_ref = attr[key]) == null) {
              attr[key] = value;
            }
          }
        }
      }
    }
    return attr;
  };

  initFirstLine = function(twoDim) {
    var element, y, _results;
    _results = [];
    for (element in firstLineSchema) {
      y = firstLineSchema[element];
      _results.push(twoDim.addElement(element, 0, y));
    }
    return _results;
  };

  generateFirstPart = function(twoDim, elements) {
    var element, key, line, lowerKey, _results;
    _results = [];
    for (key in elements) {
      element = elements[key];
      if (!(!(key === 'attributes' || key === 'parameters'))) {
        continue;
      }
      lowerKey = key.toLowerCase();
      if (famSchema[lowerKey] != null) {
        _results.push(twoDim.addElement(element, famSchema[lowerKey].row, famSchema[lowerKey].column));
      } else {
        if (twoDim.maxX < 2) {
          line = 2;
        } else {
          line = twoDim.maxX + 1;
        }
        twoDim.addElement(key, line, 0);
        _results.push(twoDim.addElement(element, line, 1));
      }
    }
    return _results;
  };

  firstAttributesLine = function(twoDim) {
    var column, key, line, _results;
    line = twoDim.maxX + 1;
    twoDim.addElement("//", line, 0);
    _results = [];
    for (key in attrSchema) {
      column = attrSchema[key];
      _results.push(twoDim.addElement(key, line, column));
    }
    return _results;
  };

  computeOrder = function(type, lastOrder) {
    var value, _ref;
    if (lastOrder == null) {
      lastOrder = 0;
    }
    value = lastOrder + ((_ref = autonumRules[type]) != null ? _ref : 10);
    return value;
  };

  generateAttributes = function(twoDim, attributes, myParent, param) {
    var attrContent, attrId, currentContent, currentOrder, currentParent, currentType, key, line, modAttr, _results;
    _results = [];
    for (attrId in attributes) {
      attrContent = attributes[attrId];
      modAttr = false;
      line = twoDim.maxX + 1;
      twoDim.addElement(attrId, line, 1);
      currentOrder = void 0;
      currentParent = myParent;
      currentType = void 0;
      if (args.computeDefaultValue) {
        attrContent = populateDefaultValues(attrContent);
      }
      for (key in attrContent) {
        currentContent = attrContent[key];
        key = key.toLowerCase();
        if (attrSchema[key] != null) {
          if (key === "parent") {
            currentParent = currentContent;
          }
          if (key === "order") {
            currentOrder = currentContent;
            if (!isNaN(parseInt(currentOrder, 10))) {
              twoDim.currentOrder = parseInt(currentOrder, 10);
            }
          }
          if (key === "type") {
            currentType = currentContent;
          }
          twoDim.addElement(currentContent, line, attrSchema[key]);
        } else {
          if (__indexOf.call(notAttrSchema, key) < 0) {
            throw "Unknown " + key;
          }
        }
        if (key === "modattr") {
          modAttr = true;
        }
      }
      if (param) {
        twoDim.addElement("PARAM", line, 0);
        if (args.autonum && !(currentOrder != null)) {
          twoDim.currentOrder = computeOrder(currentType, twoDim.currentOrder);
          twoDim.addElement(twoDim.currentOrder, line, attrSchema["order"]);
        }
      } else {
        if (modAttr) {
          twoDim.addElement("MODATTR", line, 0);
        } else {
          twoDim.addElement("ATTR", line, 0);
          if (currentType == null) {
            throw "Attr " + attrId + " needs a type";
          }
          if (args.autonum && !(currentOrder != null)) {
            twoDim.currentOrder = computeOrder(currentType, twoDim.currentOrder);
            twoDim.addElement(twoDim.currentOrder, line, attrSchema["order"]);
          }
        }
      }
      if (currentParent != null) {
        twoDim.addElement(currentParent, line, 2);
      }
      if (attrContent["default"] != null) {
        twoDim.addElement("DEFAULT", line + 1, 0);
        twoDim.addElement(attrId, line + 1, 1);
        twoDim.addElement(attrContent["default"], line + 1, 2);
      }
      if (attrContent.children != null) {
        _results.push(generateAttributes(twoDim, attrContent.children, attrId, param));
      } else {
        _results.push(void 0);
      }
    }
    return _results;
  };

  analyse = function(elements) {
    var twoDim;
    if (elements) {
      twoDim = new TwoDimStruc();
      initFirstLine(twoDim);
      twoDim.addElement("BEGIN", 1, 0);
      generateFirstPart(twoDim, elements);
      if (elements["attributes"] != null) {
        firstAttributesLine(twoDim);
        generateAttributes(twoDim, elements["attributes"]);
      }
      if (elements["parameters"] != null) {
        firstAttributesLine(twoDim);
        generateAttributes(twoDim, elements["parameters"], void 0, true);
      }
      twoDim.addElement("END", twoDim.maxX + 1, 0);
      return twoDim;
    }
  };

  parse = function(fileName, fileContent, callBack) {
    var ext, parser;
    if (fileContent) {
      ext = fileName.substr(fileName.lastIndexOf('.') + 1).toLowerCase();
      if (usableFormat[ext] != null) {
        if (ext !== "xml") {
          return callBack(usableFormat[ext](fileContent));
        } else {
          parser = new xml2js.Parser();
          return parser.parseString(fileContent, function(err, result) {
            if (err) {
              throw err;
            }
            return callBack(result);
          });
        }
      } else {
        throw "Unknown type of file " + ext;
      }
    } else {
      throw "The file " + fileName + " is empty";
    }
  };

  canBeParsed = function(fileName) {
    var ext;
    ext = fileName.substr(fileName.lastIndexOf('.') + 1).toLowerCase();
    return usableFormat[ext] != null;
  };

  analyseFile = function(inputFileName, outputFileName) {
    return function(err, content) {
      return parse(inputFileName, content, function(elements) {
        var twoDim, write;
        twoDim = analyse(elements);
        return fs.writeFile(outputFileName, twoDim.convertToCSV(), write = function(err) {
          if (err) {
            throw err;
          } else {
            return console.log(outputFileName + " is saved");
          }
        });
      });
    };
  };

  analyseAPath = function(path) {
    var checkIfExist;
    return fs.exists(path, checkIfExist = function(exist) {
      if (exist) {
        return fs.stat(path, function(err, stats) {
          var outputFileName;
          if (err) {
            throw err;
          }
          if (stats.isFile() && canBeParsed(path)) {
            console.log("Analyse " + path);
            outputFileName = getCSVFileName(path);
            return fs.readFile(path, "utf8", analyseFile(path, outputFileName));
          } else {
            return fs.readdir(path, function(err, fileNames) {
              var fileName, _i, _len, _results;
              if (fileNames) {
                _results = [];
                for (_i = 0, _len = fileNames.length; _i < _len; _i++) {
                  fileName = fileNames[_i];
                  _results.push(analyseAPath(pathUtil.join(path, fileName)));
                }
                return _results;
              }
            });
          }
        });
      } else {
        return console.log(path + " notExist");
      }
    });
  };

  getCSVFileName = function(inputFileName) {
    var baseName;
    baseName = inputFileName.substr(0, inputFileName.lastIndexOf('.'));
    baseName += ".csv";
    return baseName;
  };

  parser = new argparse.ArgumentParser({
    version: '0.0.1',
    addHelp: true,
    description: 'convert a modern fam def to old style'
  });

  parser.addArgument(['input'], {
    help: 'input file (json, cson, xml or YAML) or input dir (if --watch used)'
  });

  parser.addArgument(['-w', '--watch'], {
    help: 'rebuild the file if source modified',
    defaultValue: false
  });

  parser.addArgument(['--autonum'], {
    help: 'compute position number',
    defaultValue: true
  });

  parser.addArgument(['--computeDefaultValue'], {
    help: 'add default value',
    defaultValue: true
  });

  args = parser.parseArgs();

  if (args.input) {
    if (args.watch) {
      if (fs.statSync(args.input).isDirectory()) {
        dir = args.input;
      } else {
        dir = pathUtil.dirname(args.input);
      }
      console.log("Start watching ", dir);
      fs.watch(args.input, onChange = function(event, fileName) {
        if (fileName && canBeParsed(fileName)) {
          return analyseAPath(pathUtil.join(dir, fileName));
        }
      });
    }
    analyseAPath(args.input);
  } else {
    parser.printHelp();
  }

  process.on('uncaughtException', function(err) {
    var command, msg;
    msg = 'Caught exception : ' + err;
    msg = msg.replace(/["]/mgi, '\\"').replace(/[']/mgi, "\\'").replace(/[\n]/mgi, ' ');
    command = 'notify-send --hint=int:transient:1 "Generate Family Error" "' + msg + '"';
    exec(command);
    return console.log(msg);
  });

}).call(this);
